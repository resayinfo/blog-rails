<div class="articles">
  <h1 class="page-header" align="center">"<%= @article.title %>"<br>By: <%= @article.author %></h1>
  <h2 class="articles-show-updated-sub-header">Created <%= @article.created_at.strftime('%b %-d, %Y, %l:%M %p, %Z') %><br>Updated <%= @article.updated_at.strftime('%b %-d, %Y, %l:%M %p, %Z') if @article.updated_at.present? %></h2>

    <div class="articles-show-lefty">
      <%= raw(@article.text) %>
    </div>

  <table>
    <tr>
      <% if current_user.has_role? :superadmin or current_user.has_role? :god %>
        <td><%= link_to 'Edit', edit_article_path(@article), class: 'btn btn-default' %></td>
        <td><%= link_to 'Delete', article_path(@article) , class: 'btn btn-danger',
                                method: :delete, data: { confirm: 'Are you sure?' } %></td>
      <% end %>
    </tr>
  </table>

  <h2 class="comments">Comments</h2>
  <%= render @article.comments %>
  <% if can? :manage, Comment %>
  <h3 class="comment">Add a comment:</h3>
  <%= render "comments/form" %>
  <% end %>

  <script>
  /**
  * uiMorphingButton_fixed.js v1.0.0
  * http://www.codrops.com
  *
  * Licensed under the MIT license.
  * http://www.opensource.org/licenses/mit-license.php
  *
  * Copyright 2014, Codrops
  * http://www.codrops.com
  */
    ;( function( window ) {

      'use strict';

      var transEndEventNames = {
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionend',
        'OTransition': 'oTransitionEnd',
        'msTransition': 'MSTransitionEnd',
        'transition': 'transitionend'
      },
      transEndEventName = transEndEventNames[ Modernizr.prefixed( 'transition' ) ],
      support = { transitions : Modernizr.csstransitions };

      function extend( a, b ) {
        for( var key in b ) {
          if( b.hasOwnProperty( key ) ) {
            a[key] = b[key];
          }
        }
        return a;
      }

      function UIMorphingButton( el, options ) {
        this.el = el;
        this.options = extend( {}, this.options );
        extend( this.options, options );
        this._init();
      }

      UIMorphingButton.prototype.options = {
        closeEl : '',
        onBeforeOpen : function() { return false; },
        onAfterOpen : function() { return false; },
        onBeforeClose : function() { return false; },
        onAfterClose : function() { return false; }
      }

      UIMorphingButton.prototype._init = function() {
        // the button
        this.button = this.el.querySelector( 'button' );
        // state
        this.expanded = false;
        // content el
        this.contentEl = this.el.querySelector( '.morph-content' );
        // init events
        this._initEvents();
      }

      UIMorphingButton.prototype._initEvents = function() {
        var self = this;
        // open
        this.button.addEventListener( 'click', function() { self.toggle(); } );
        // close
        if( this.options.closeEl !== '' ) {
          var closeEl = this.el.querySelector( this.options.closeEl );
          if( closeEl ) {
            closeEl.addEventListener( 'click', function() { self.toggle(); } );
          }
        }
      }

      UIMorphingButton.prototype.toggle = function() {
        if( this.isAnimating ) return false;

        // callback
        if( this.expanded ) {
          this.options.onBeforeClose();
        }
        else {
          // add class active (solves z-index problem when more than one button is in the page)
          classie.addClass( this.el, 'active' );
          this.options.onBeforeOpen();
        }

        this.isAnimating = true;

        var self = this,
        onEndTransitionFn = function( ev ) {
          if( ev.target !== this ) return false;

          if( support.transitions ) {
            // open: first opacity then width/height/left/top
            // close: first width/height/left/top then opacity
            if( self.expanded && ev.propertyName !== 'opacity' || !self.expanded && ev.propertyName !== 'width' && ev.propertyName !== 'height' && ev.propertyName !== 'left' && ev.propertyName !== 'top' ) {
              return false;
            }
            this.removeEventListener( transEndEventName, onEndTransitionFn );
          }
          self.isAnimating = false;

          // callback
          if( self.expanded ) {
            // remove class active (after closing)
            classie.removeClass( self.el, 'active' );
            self.options.onAfterClose();
          }
          else {
            self.options.onAfterOpen();
          }

          self.expanded = !self.expanded;
        };

        if( support.transitions ) {
          this.contentEl.addEventListener( transEndEventName, onEndTransitionFn );
        }
        else {
          onEndTransitionFn();
        }

        // set the left and top values of the contentEl (same like the button)
        var buttonPos = this.button.getBoundingClientRect();
        // need to reset
        classie.addClass( this.contentEl, 'no-transition' );
        this.contentEl.style.left = 'auto';
        this.contentEl.style.top = 'auto';

        // add/remove class "open" to the button wraper
        setTimeout( function() {
          self.contentEl.style.left = buttonPos.left + 'px';
          self.contentEl.style.top = buttonPos.top + 'px';

          if( self.expanded ) {
            classie.removeClass( self.contentEl, 'no-transition' );
            classie.removeClass( self.el, 'open' );
          }
          else {
            setTimeout( function() {
              classie.removeClass( self.contentEl, 'no-transition' );
              classie.addClass( self.el, 'open' );
            }, 25 );
          }
        }, 25 );
      }

      // add to global namespace
      window.UIMorphingButton = UIMorphingButton;

    })( window );
  </script>
  <div class="morph-button morph-button-sidebar morph-button-fixed">
    <button type="button"><span class="icon icon-cog">Settings Menu</span></button>
    <div class="morph-content">
      <div>
        <div class="content-style-sidebar">
          <span class="icon icon-close">Close the overlay</span>
          <h2>Settings</h2>
          <ul>
            <li><a class="icon icon-camera" href="#">Default filters</a></li>
            <li><a class="icon icon-server" href="#">Storage Use</a></li>
            <li><a class="icon icon-heart" href="#">Favorites</a></li>
            <li><a class="icon icon-zoom-in" href="#">Readability</a></li>
            <li><a class="icon icon-microphone" href="#">Speech</a></li>
            <li><a class="icon icon-cloud" href="#">Uploads</a></li>
            <li><a class="icon icon-user" href="#">Profile</a></li>
            <li><a class="icon icon-briefcase" href="#">Documents</a></li>
            <li><a class="icon icon-globe" href="#">Global Options</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div><!-- morph-button -->
  <script>
    (function() {
      var docElem = window.document.documentElement, didScroll, scrollPosition;

      // trick to prevent scrolling when opening/closing button
      function noScrollFn() {
        window.scrollTo( scrollPosition ? scrollPosition.x : 0, scrollPosition ? scrollPosition.y : 0 );
      }

      function noScroll() {
        window.removeEventListener( 'scroll', scrollHandler );
        window.addEventListener( 'scroll', noScrollFn );
      }

      function scrollFn() {
        window.addEventListener( 'scroll', scrollHandler );
      }

      function canScroll() {
        window.removeEventListener( 'scroll', noScrollFn );
        scrollFn();
      }

      function scrollHandler() {
        if( !didScroll ) {
          didScroll = true;
          setTimeout( function() { scrollPage(); }, 60 );
        }
      };

      function scrollPage() {
        scrollPosition = { x : window.pageXOffset || docElem.scrollLeft, y : window.pageYOffset || docElem.scrollTop };
        didScroll = false;
      };

      scrollFn();

      var el = document.querySelector( '.morph-button' );

      new UIMorphingButton( el, {
        closeEl : '.icon-close',
        onBeforeOpen : function() {
          // don't allow to scroll
          noScroll();
        },
        onAfterOpen : function() {
          // can scroll again
          canScroll();
          // add class "noscroll" to body
          classie.addClass( document.body, 'noscroll' );
          // add scroll class to main el
          classie.addClass( el, 'scroll' );
        },
        onBeforeClose : function() {
          // remove class "noscroll" to body
          classie.removeClass( document.body, 'noscroll' );
          // remove scroll class from main el
          classie.removeClass( el, 'scroll' );
          // don't allow to scroll
          noScroll();
        },
        onAfterClose : function() {
          // can scroll again
          canScroll();
        }
      } );
    })();
  </script>

</div><!--. articles -->
